\documentclass[a4paper,12pt,fleqn]{scrartcl}
\usepackage[l2tabu,orthodox]{nag}% Old habits die hard. All the same, there are commands, classes and packages which are outdated and superseded. nag provides routines to warn the user about the use of those.

\usepackage[all,error]{onlyamsmath}% Error on deprecated math commands like $$ $$.
\usepackage[strict=true]{csquotes}

%\usepackage{color}

\usepackage{listings}
\lstset{frame=single,framerule=0pt,language={C},showstringspaces=false,numbers=left,columns=fullflexible}


% COMP2111-specific macros. See
% http://www.cse.unsw.edu.au/~cs2111/18s1/LaTeX/primer.html
\usepackage{2111defs2}
\usepackage[colorlinks=true]{hyperref}

\newcommand{\assn}[1]{{\color{red}\left\{#1\right\}}}
\newcommand{\remark}[1]{{\sffamily\color{blue}{#1}}}

% define some convenience macros specific to this task
\newcommand{\perm}{\mathsf{perm}}
%title variable
\title{Assignment 2}
\author{Ruofei HUANG(z5141448)\and
Anqi ZHU(z5141541)
}


\newcommand{\variant}[3]{(#1:#2\mapsto #3)}
\newcommand{\oldwhatever}[4]{\variant{#1}{#2}{\variant{#1[#2]}{#3}{#4}}}
\newcommand{\whatever}[4]{\variant{#1}{#2\mapsto #3}{#4}}
\newcommand{\ah}{\mathsf{a}}
\newcommand{\be}{\mathsf{b}}
\newcommand{\length}[1]{\left|#1\right|}
\newcommand{\noof}[2]{\left\|#1\right\|_{#2}}
\def\L{\mathcal{L}}
\begin{document}
\maketitle
\section{Task 1}
\subsection{Prime }
A number is a prime is a nautal number greater than 1 that 
cannot be formed by mutiplying two smaller number\footnote{
Direct reference from Wikipedia:
\url{https://en.wikipedia.org/wiki/Prime_number}}.
Hence we can have the definition by set theory:
\begin{gather*}
  Prime = \{ n | \neg \Exi{x\in (2..n-1)}{x|n} \}
\end{gather*} 

\subsection{Reverse}
To define a emirp, a mathmatical function to decribe a number's reverse
would be helpful. 
By the spec in verifying reversen\footnote{A 
proof provided by Lecturer in Control of this course on 
\url{https://www.cse.unsw.edu.au/~cs2111/18s1/lec/reverse.pdf} },
we have this definition:
\begin{gather*}
  rev(n) = \sum_{i= 0}^{c(n)}(S_i 10^i)
\end{gather*}
where:
\begin{gather*}
  c(n) = \lfloor log_{10}(n)\rfloor ,\\
  S = [10]^* ,\\
  n \in \nat \And n = \sum_{i=0}^{c(n)}(S_i 10 ^{(c(n)-i)})
\end{gather*}
Hence, we can justify the spec of 
$\PROC \ reversen(\VALUE \ n: \ints, \RESULT \ r: \ints )$ 
as 
\begin{gather*}
  r:[\True, r = rev(n)]
\end{gather*}


\subsection{Emirp}
An emirp is a prime number that results iin a different prime when its 
decimal digits are reverse\footnote{
  Another reference from Wikipedia :\url{https://en.wikipedia.org/wiki/Emirp}
}. Hence a definition of emirp can be construct as follow:
\begin{gather*}
  n \in Emirp \iff n \in Prime \And rev(n) \in Prime 
\end{gather*}
We also construct another function to help us find the $n^{th}$ emirp, 
which is as follow:
\begin{gather*}
  isEmirp(n)= \begin{cases}
    0 & \text{if } n \in Prime \And rev(n) \in Prime \\
    1 & \text{else }
  \end{cases}
\end{gather*}
\subsubsection{Procedure Call}
Also for our usage in the procedure call in the main programme, 
we have develop a procedure to do the same thing. Hence we have this spec
\begin{gather*}
  \PROC \ ISEMIRP(\VALUE \ n: \nat, \RESULT \ w)\cdot \\
  \nt{
  n,w:
  [
    \True, 
    \left(
      \begin{array}{l}
        (w= 1\And rev(n)\neq n \And n \in Prime \And rev(n)\in Prime) \Or \\
        (w\neq 1\And \neg (rev(n)\neq n \And n \in Prime \And rev(n)\in Prime))
      \end{array}
    \right)
  ]}{(A)}
\end{gather*}

\subsubsection{Refinement Calculatiion}
\begin{align*}
  \lrefstep{(A)}{\textbf{c-frame}}{
    w:
    [
      \True , 
      \left(
        \begin{array}{l}
          (w= 1\And rev(n)\neq n \And n \in Prime \And rev(n)\in Prime) \Or \\
          (w\neq 1\And \neg (rev(n)\neq n \And n \in Prime \And rev(n)\in Prime))
        \end{array}
      \right)
    ]
  }
\end{align*}

\subsubsection{Toy Language Code}


\subsection{Pre- and Postcondition}
Our task is find the $n^{th}$ emprip, by the previous definition of $isEmirp(n)$
we can construct the pre- and postcondition in this way:
\begin{gather*}
  \PROC EMIRP(\VALUE \ n: \nat, \RESULT \ r) \\
  \nt{n: \nat ,  \RESULT \ r: \nat 
  [
    \True ,  
    \sum_{i=0}^{r}isEmirp(i)= n \And r \in Emirp
  ]}{(1)}
\end{gather*}  

\section{Task 2}





\end{document}
