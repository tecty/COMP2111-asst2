\documentclass[a4paper,12pt,fleqn]{scrartcl}
\usepackage[l2tabu,orthodox]{nag}% Old habits die hard. All the same, there are commands, classes and packages which are outdated and superseded. nag provides routines to warn the user about the use of those.

\usepackage[all,error]{onlyamsmath}% Error on deprecated math commands like $$ $$.
\usepackage[strict=true]{csquotes}

%\usepackage{color}

\usepackage{listings}
\lstset{frame=single,framerule=0pt,language={C},showstringspaces=false,numbers=left,columns=fullflexible}


% COMP2111-specific macros. See
% http://www.cse.unsw.edu.au/~cs2111/18s1/LaTeX/primer.html
\usepackage{2111defs2}
\usepackage[colorlinks=true]{hyperref}

\newcommand{\assn}[1]{{\color{red}\left\{#1\right\}}}
\newcommand{\remark}[1]{{\sffamily\color{blue}{#1}}}

% define some convenience macros specific to this task
\newcommand{\perm}{\mathsf{perm}}
%title variable
\title{Assignment 2}
\author{Ruofei HUANG(z5141448)\and
Anqi ZHU(z5141541)
}


\newcommand{\variant}[3]{(#1:#2\mapsto #3)}
\newcommand{\oldwhatever}[4]{\variant{#1}{#2}{\variant{#1[#2]}{#3}{#4}}}
\newcommand{\whatever}[4]{\variant{#1}{#2\mapsto #3}{#4}}
\newcommand{\ah}{\mathsf{a}}
\newcommand{\be}{\mathsf{b}}
\newcommand{\length}[1]{\left|#1\right|}
\newcommand{\noof}[2]{\left\|#1\right\|_{#2}}

\newcommand{\pre}{\mathit{pre}}
\newcommand{\post}{\mathit{post}}
\def\L{\mathcal{L}}
\begin{document}
\maketitle
\section{Task 1}
\subsection{Prime }
A number is a prime is a nautal number greater than 1 that 
cannot be formed by mutiplying two smaller number\footnote{
Direct reference from Wikipedia:
\url{https://en.wikipedia.org/wiki/Prime_number}}.
Hence we can have the definition by set theory:
\begin{gather*}
  Prime = \{ n | \neg \Exi{x\in (2..n-1)}{x|n} \}
\end{gather*} 
Then we can base on the GMP function that make up the spec of the 
procedure call of $\PROC \ ISPRIME(\VALUE \ n, \RESULT \ r)$ 
\begin{gather*}
  \PROC \ ISPRIME(\VALUE \ n, \RESULT \ r) \cdot \\
  [TRUE, (n \in Prime \And r > 0) \Or (n \notin Prime \And r=0)]
\end{gather*}
Which means $ ISPRIME(n)>0 
\footnote{This act as another procedure call sugar $r \Ass ISPRIME(n)$;
the complete expanded version will be 
$ISPRIME(n,r);(( r>0 \Implies r \in Prime)
\Or (\ELSE \Implies r \notin Prime))$. The continueous prove 
will follow this convension to make life easier.
} 
\Implies n \in Prime $.


\subsection{Reverse}
To define a emirp, a mathmatical function to decribe a number's reverse
would be helpful. 
By the spec in verifying reversen\footnote{A 
proof provided by Lecturer in Control of this course on 
\url{https://www.cse.unsw.edu.au/~cs2111/18s1/lec/reverse.pdf} },
we have this definition:
\begin{gather*}
  rev(n) = \sum_{i= 0}^{c(n)}(S_i 10^i)
\end{gather*}
where:
\begin{gather*}
  c(n) = \lfloor log_{10}(n)\rfloor ,\\
  S = [10]^* ,\\
  n \in \nat \And n = \sum_{i=0}^{c(n)}(S_i 10 ^{(c(n)-i)})
\end{gather*}
Hence, we can justify the spec of 
$\PROC \ reversen(\VALUE \ n: \ints, \RESULT \ r: \ints )$ 
as 
\begin{gather*}
  \PROC \ reversen(\VALUE \ n: \ints, \RESULT \ r: \ints ) \cdot \\
  r:[\True, r = rev(n)]
\end{gather*}


\subsection{Emirp}
An emirp is a prime number that results iin a different prime when its 
decimal digits are reverse\footnote{
  Another reference from Wikipedia :\url{https://en.wikipedia.org/wiki/Emirp}
}. Hence a definition of emirp can be construct as follow:
\begin{gather*}
  n \in Emirp \iff n \in Prime \And rev(n) \in Prime 
\end{gather*}
We also construct another function to help us find the $n^{th}$ emirp, 
which is as follow:
\begin{gather*}
  isEmirp(n)= \begin{cases}
    0 & \text{if } n \in Prime \And rev(n) \in Prime \\
    1 & \text{else }
  \end{cases}
\end{gather*}
\subsubsection{Procedure Call}
Also for our usage in the procedure call in the main programme, 
we have develop a procedure to do the same thing. Hence we have this spec
\begin{gather*}
  \PROC \ ISEMIRP(\VALUE \ n: \nat, \RESULT \ w)\cdot \\
  \nt{
  n,w:
  [
    \True, 
    \left(
      \begin{array}{l}
        (w= 1\And rev(n)\neq n \And n \in Prime \And rev(n)\in Prime) \Or \\
        (w\neq 1\And \neg (rev(n)\neq n \And n \in Prime \And rev(n)\in Prime))
      \end{array}
    \right)
  ]}{(A)}
\end{gather*}

\subsubsection{Refinement Calculatiion}
\begin{align*}
  \lrefstep{(A)}{\textbf{c-frame}}{
    w:
    [
      \True , 
      \left(
        \begin{array}{l}
          (w= 1\And rev(n)\neq n \And n \in Prime \And rev(n)\in Prime) \Or \\
          (w\neq 1\And \neg (rev(n)\neq n \And n \in Prime \And rev(n)\in Prime))
        \end{array}
      \right)
    ]
  }
  \displaybreak 
  \\
  \refstep{\textbf{i-loc}}{
    r\cdot w:
    [
      \True , 
      \left(
        \begin{array}{l}
          (w= 1\And rev(n)\neq n \And n \in Prime \And rev(n)\in Prime) \Or \\
          (w\neq 1\And \neg (rev(n)\neq n \And n \in Prime \And rev(n)\in Prime))
        \end{array}
      \right)
    ] 
  }
  \\
  \refstep{\textbf{seq2}}{
    \nt{r:
    [
      \True , 
      r= rev(n)
    ];}{(B)}\\
    &
    \nt{r\cdot w:
    [
      r= rev(n) , 
      \left(
        \begin{array}{l}
          (w= 1\And rev(n)\neq n \And n \in Prime \And rev(n)\in Prime) \Or \\
          (w\neq 1\And \neg (rev(n)\neq n \And n \in Prime \And rev(n)\in Prime))
        \end{array}
      \right)
    ]}{(C)}
  }
  \\
  \lrefstep{(B)}{\textbf{ass},need to be justify? }{
    r := reversen(n)
  }
  % 
  \\ 
  \lrefstep{(C)}{\textbf{s-pos}, $r= rev(n)$, replace all the rev in the post}{
    \nt{
    r\cdot w:
    [
      r= rev(n) , 
      \left(
        \begin{array}{l}
          (w= 1\And r\neq n \And n \in Prime \And r\in Prime) \Or \\
          (w\neq 1\And \neg (r\neq n \And n \in Prime \And r\in Prime))
        \end{array}
      \right)
    ]}{(C')}
  }
  \\ 
  \refstep{\textbf{if}}{
    \IF ~r \neq n ~ \\
    &\THEN     
      \nt{r\cdot w:
      [
        r \neq n, 
        \post{(C')}
      ]}{(D)}\\
    &\ELSE 
      \nt{r\cdot w:
      [
        r = n , 
        \post{(C')}
      ]}{(E)}
    \\
    &\FI \\
  }
  \\
  \lrefstep{(D)}{\textbf{if}}{
    % TODO: \in Prime \neq isPrimem (n)
    \IF ~ ISPRIME(n) > 0 ~ \\
    &\THEN     
      \nt{r\cdot w:
      [
        r \neq n \And n \in Prime, 
        \post{(C')}
      ]}{(F)}\\
    &\ELSE 
      \nt{r\cdot w:
      [
        r \neq n \And n \notin Prime, 
        \post{(C')}
      ]}{(G)}
    \\
    &\FI \\
  }
  \\
  \lrefstep{(F)}{\textbf{if}}{
    % TODO: \in Prime \neq isPrimem (n)
    \IF ~ISPRIME(r) > 0  ~ \\
    &\THEN     
      \nt{r\cdot w:
      [
        r \neq n \And n \in Prime \And r \in Prime,
        \post{(C')}
      ]}{(G)}\\
    &\ELSE 
      \nt{r\cdot w:
      [
        r \neq n \And n \in Prime \And r \notin Prime, 
        \post{(C')}
      ]}{(H)}
    \\
    &\FI \\
  }
  % TODO: Need to be justify
  \lrefstep{(E)(G)(H)}{\textbf{ass}, need to be justify}{
    w \Ass 0
  }
  \\
  % TODO: Need to be justify 
  \lrefstep{(G)}{\textbf{ass}, need to be justify}{
    w \Ass 1
  }
\end{align*}
\subsubsection{Justification of}

\subsubsection{Toy Language Code}
\begin{gather*}
  r \Ass reversen(n)
  \IF ~r\neq n ~ \\
  \THEN \\
  \qquad \IF ~ ISPRIME(n) >0 ~ \\ 
  \qquad \THEN \\
  \qquad \qquad \IF ~ ISPRIME(r) > 0~ \\ 
  \qquad \qquad \THEN \ w\Ass 1\\
  \qquad \qquad \ELSE \ w\Ass 0\\
  \qquad \qquad \FI\\
  \qquad \ELSE \ w\Ass 0 \\
  \qquad \FI\\
  \ELSE \ w\Ass 0 \\
  \FI\\
\end{gather*}

\subsection{Pre- and Postcondition}
Our task is find the $n^{th}$ emprip, by the previous definition of $isEmirp(n)$
we can construct the pre- and postcondition in this way:
\begin{gather*}
  \PROC \ EMIRP(\VALUE \ n: \nat, \RESULT \ r) \\
  \nt{n: \nat ,  \RESULT \ r: \nat 
  [
    \True ,  
    \sum_{i=0}^{r}isEmirp(i)= n \And r \in Emirp
  ]}{(1)}
\end{gather*}  

\section{Task 2}
\begin{align*}
  \lrefstep{(1)}{\textbf{c-frame}}{
    r
    [
      \True ,  
      \sum_{i=0}^{r}isEmirp(i)= n \And r \in Emirp
    ]
  }
  \\
  \refstep{\textbf{i-loc}}{
    count \cdot r
    [
      \True ,  
      \sum_{i=0}^{r}isEmirp(i)= n \And r \in Emirp
    ]
  }
  \\
  \refstep{\textbf{i-loc}}{
    \nt{
      count , r
      [
        \True ,  
        Inv
      ]
    }{(2)};\\
    &\nt{
      count , r
      [
        Inv,
        \sum_{i=0}^{r}isEmirp(i)= n \And r \in Emirp
      ]
    }{(3)}
  }
\end{align*}
Where the loop invariant is defined by:
% TODO: Modify Inv 
\begin{gather*}
  Inv = 
  \left( \begin{array}{l}
    count = \sum_{i=0}^{count}isEmirp(i) \And count \leq n
  \end{array}\right)
\end{gather*}
\begin{align*}
  \lrefstep{(2)}{Routine work, set up the variable of loop}{
    r \Ass 1; count \Ass 0;
  }
  \\
  % TODO: Check whether it's correct s-post 
  \lrefstep{(3)}{\textbf{s-post}}{
    count , r
    [
      Inv,
      % \sum_{i=0}^{r}isEmirp(i)= n \And r \in Emirp \And count = n
      Inv \And count = n
    ]
  }
  \\
  \refstep {\textbf{while}}{
    \WHILE ~count \neq n ~ \DO \\ 
    & \qquad 
    \nt{
      count , r
      [
        Inv \And count \neq n ,
        Inv 
      ]
    }{4}
    \\
    &\OD
  }
  \\
  \lrefstep{(4)}{\textbf{seq2}}{
    \nt{
      r
      [
        Inv \And count \neq n ,
        Inv \subst{r+1}{r}
      ];
    }{(5)}
    \\
    &\nt{
      count, r
      [
        Inv \subst{r+1}{r},
        Inv  
      ]
    }{(6)}
  }
  \\
  % TODO : whether it need to justify
  \lrefstep{(5)}{\textbf{ass, need to justify?}}{
    r \Ass r+1;
  }
  % TODO: Need to justify
  \\
  \lrefstep{(6)}{\textbf{ass, need to justify?}}{
    count \Ass count + ISEMIRP(r);
  }
\end{align*}
\subsubsection{Toy Language Programme}
We collect all out toy language code, we have 
\begin{gather*}
  r \Ass 1; count \Ass 0;\\
  \WHILE ~count \neq n ~ \DO \\
  \qquad r \Ass r+1;\\
  \qquad count \Ass count + ISEMIRP(r);
  \OD 
\end{gather*}


\subsection{Task 3}
\subsection{Task 4}

\end{document}
