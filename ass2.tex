\documentclass[a4paper,12pt,fleqn]{scrartcl}
\usepackage[l2tabu,orthodox]{nag}% Old habits die hard. All the same, there are commands, classes and packages which are outdated and superseded. nag provides routines to warn the user about the use of those.

\usepackage[all,error]{onlyamsmath}% Error on deprecated math commands like $$ $$.
\usepackage[strict=true]{csquotes}

%\usepackage{color}

\usepackage{listings}
\lstset{frame=single,framerule=0pt,language={C},showstringspaces=false,numbers=left,columns=fullflexible}


% COMP2111-specific macros. See
% http://www.cse.unsw.edu.au/~cs2111/18s1/LaTeX/primer.html
\usepackage{2111defs2}
\usepackage[colorlinks=true]{hyperref}

\newcommand{\assn}[1]{{\color{red}\left\{#1\right\}}}
\newcommand{\remark}[1]{{\sffamily\color{blue}{#1}}}

% define some convenience macros specific to this task
\newcommand{\perm}{\mathsf{perm}}
%title variable
\title{Assignment 2}
\author{Ruofei HUANG(z5141448)\and
Anqi ZHU(z5141541)
}


\newcommand{\variant}[3]{(#1:#2\mapsto #3)}
\newcommand{\oldwhatever}[4]{\variant{#1}{#2}{\variant{#1[#2]}{#3}{#4}}}
\newcommand{\whatever}[4]{\variant{#1}{#2\mapsto #3}{#4}}
\newcommand{\ah}{\mathsf{a}}
\newcommand{\be}{\mathsf{b}}
\newcommand{\length}[1]{\left|#1\right|}
\newcommand{\noof}[2]{\left\|#1\right\|_{#2}}

\newcommand{\pre}{\mathit{pre}}
\newcommand{\post}{\mathit{post}}
\def\L{\mathcal{L}}
\begin{document}
\maketitle
\section{Task 1}
\subsection{Prime }
We define a number $n$ to be a prime if it is a natural number greater than 1 and 
cannot be formed by mutiplying two natural numbers (bigger than 1) smaller than 
itself\footnote{
Reference from Wikipedia:
\url{https://en.wikipedia.org/wiki/Prime_number}}.
Hence we can describe the set containing all primes as:
\begin{gather*}
  Prime = \{ n\in \nat | \neg (\Exi{x\in (1..n-1)}{x|n}) \And n > 1 \}
\end{gather*} 
GMP provides a function called ISPRIME() to check if a certain number $n$ is a 
prime or not. The procedure of this function can be expressed as:
\begin{gather*}
  \PROC \ ISPRIME(\VALUE \ n, \RESULT \ p) \cdot \\
  n, p: [TRUE, (n_0 \in Prime \And p > 0) \Or (n_0 \notin Prime \And p<=0)]
\end{gather*}
We shall use its procedure call sugar, $\RESULT \ p = ISPRIME(\VALUE \ n)$, to 
verify primes later in our refinement.

\subsection{Reverse}
By the spec in verifying a number $v$ which is the reverse of the number $n$
\footnote{A proof provided by Lecturer in Control of this course on 
\url{https://www.cse.unsw.edu.au/~cs2111/18s1/lec/reverse.pdf} },
we can have the following mathematical definition:
\begin{gather*}
  v = rev(n) = \sum_{i= 0}^{c(n)}(S_i 10^i)
\end{gather*}
where:
\begin{gather*}
  c(n) = \lfloor log_{10}(n)\rfloor ,\\
  S = [10]^* ,\\
  n \in \nat \And n = \sum_{i=0}^{c(n)}(S_i 10 ^{(c(n)-i)})
\end{gather*}
Then we can simplify the spec of 
$\PROC \ reversen(\VALUE \ n: \nat, \RESULT \ v: \nat )$ 
given by the lecturer, as 
\begin{gather*}
  \PROC \ reversen(\VALUE \ n: \nat, \RESULT \ v: \nat ) \cdot \\
  r, v:[\True, v = rev(r_0)]
\end{gather*}

\subsection{Emirp}
An emirp $n$ is a prime number that results in a different prime when its 
decimal digits are reversed\footnote{
  Another reference from Wikipedia :\url{https://en.wikipedia.org/wiki/Emirp}
}. The definition of emirp can be construct in mathematical semantics as follows:
\begin{gather*}
  n \in Emirp \iff n \in Prime \And rev(n) \in Prime \And n \neq rev(n)
\end{gather*}
Then we can define a function to check if the specified number $n$ is an emirp.
The function is such as:
\begin{gather*}
  isEmirp(n)= \begin{cases}
    1 & \text{if } n \in Prime \And rev(n) \in Prime \And n \neq rev(n)\\
    0 & \text{else }
  \end{cases}
\end{gather*}
We use 0 and 1 as our returning value of the function, so that we can find out 
how many emirps are found in the range of 2 .. $n$ according to the following 
mathematics semantics:
\begin{gather*}
  \textbf{the number of emirps found} = \sum_{i=0}^{n}isEmirp(i)
\end{gather*}
where:
\begin{gather*}
  n\in \nat_{>1}
\end{gather*}

\subsubsection{Derivation of ISEMIRP() Procedure Call}
We want to transfer the isEmirp() function into a procedure so that we can use it in 
our later refinement. We start with a spec of the procedure.
\begin{gather*}
  \PROC \ ISEMIRP(\VALUE \ n: \nat, \RESULT \ w)\cdot \\
  \nt{
  n,w:
  [
    \True, 
    \left(
      \begin{array}{l}
        (w= 1\And rev(n_0)\neq n_0 \And n_0 \in Prime \And rev(n_0)\in Prime) \Or \\
        (w= 0\And \neg (rev(n_0)\neq n_0 \And n_0 \in Prime \And rev(n_0)\in Prime))
      \end{array}
    \right)
  ]}{(A)}
\end{gather*}

\begin{align*}
  \lrefstep{(A)}{\textbf{c-frame}}{
    w:
    [
      \True , 
      \left(
        \begin{array}{l}
          (w= 1\And rev(n)\neq n \And n \in Prime \And rev(n)\in Prime) \Or \\
          (w= 0\And \neg (rev(n)\neq n \And n \in Prime \And rev(n)\in Prime))
        \end{array}
      \right)
    ]
  }
  \\
  \refstep{\textbf{i-loc}}{
    \textbf{var}\ r\cdot r,w:
    [
      \True , 
      \left(
        \begin{array}{l}
          (w= 1\And rev(n)\neq n \And n \in Prime \And rev(n)\in Prime) \Or \\
          (w= 0\And \neg (rev(n)\neq n \And n \in Prime \And rev(n)\in Prime))
        \end{array}
      \right)
    ] 
  }
  \\
  \refstep{\textbf{seq2}}{
    \nt{r:
    [
      \True , 
      r= rev(n)
    ];}{(B)}\\
    &
    \nt{r\cdot w:
    [
      r= rev(n) , 
      \left(
        \begin{array}{l}
          (w= 1\And rev(n)\neq n \And n \in Prime \And \\
          rev(n)\in Prime)\Or (w= 0\And \neg (rev(n)\neq n\\
          \And n \in Prime \And rev(n)\in Prime))
        \end{array}
      \right)
    ]}{(C)}
  }
  \\
  \lrefstep{(B)}{\textbf{proc}}{
    reversen(n, r);
  }
  % 
  %  a c-frame is require
  \\ 
  \lrefstep{(C)}{\textbf{s-post}, justified below in 1.3.2}{
    \nt{
    r\cdot w:
    [
      r= rev(n) , 
      \left(
        \begin{array}{l}
          (w= 1\And r\neq n \And n \in Prime \And r\in Prime) \Or \\
          (w= 0\And \neg (r\neq n \And n \in Prime \And r\in Prime))
        \end{array}
      \right)
    ]}{(C')}
  }
  %
  \\ 
  \lrefstep{(C')}{\textbf{if}}{
    \IF ~r \neq n ~ \\
    &\THEN\      
      \nt{r\cdot w:
      [
        r \neq n \And \pre{(C')}, 
        \post{(C')}
      ]}{(D)}\\
    &\ELSE\  
      \nt{r\cdot w:
      [
        r = n \And \pre{(C')}, 
        \post{(C')}
      ]}{(E)}
    \\
    &\FI \\
  }
  \\
  \lrefstep{(D)}{\textbf{if}}{
    % TODO: \in Prime \neq isPrimem (n)
    \IF ~ ISPRIME(n) > 0 ~ \\
    &\THEN\     
      \nt{r\cdot w:
      [
        \pre{(D)} \And n \in Prime, 
        \post{(C')}
      ]}{(F)}\\
    &\ELSE\  
      \nt{r\cdot w:
      [
        \pre{(D)} \And n \notin Prime, 
        \post{(C')}
      ]}{(G)}
    \\
    &\FI \\
  }
  \\
  \lrefstep{(F)}{\textbf{if}}{
    % TODO: \in Prime \neq isPrimem (n)
    \IF ~ISPRIME(r) > 0  ~ \\
    &\THEN     
      \nt{r\cdot w:
      [
        \pre{(F)} \And r \in Prime,
        \post{(C')}
      ]}{(H)}\\
    &\ELSE 
      \nt{r\cdot w:
      [
        \pre{(F)} \And r \notin Prime, 
        \post{(C')}
      ]}{(I)}
    \\
    &\FI \\
  }
  % TODO: Need to be justify
  \lrefstep{(E)(G)(I)}{\textbf{ass}, justfied below in 1.3.3}{
    w \Ass 0
  }
  \\
  % TODO: Need to be justify 
  \lrefstep{(H)}{\textbf{ass}, justified below in 1.3.4}{
    w \Ass 1
  }
\end{align*}
We gather the code for the procedure body of ISEMIRP:
\begin{gather*}
  \textbf{var}\ r;\\
  reversen(n, r);\\
  \IF~ r\neq n\ \THEN~ \\
  \qquad \IF~ ISPRIME(n)>0\ \THEN~ \\
  \qquad\qquad \IF~ ISPRIME(r)>0\\
  \qquad\qquad\THEN~ w:=1;\\
  \qquad\qquad \ELSE~ w:=0; \\
  \qquad\qquad \FI~\\
  \qquad \ELSE~ w:=0;\\
  \qquad \FI~\\
  \ELSE~ w:=0;\\
  \FI~
\end{gather*}


\subsubsection{Proof of $\pre{(C)\subst{r_0}r\subst{w_0}w}\And \post{(C')}\Implies \post{(C)}$}
\subsubsection{Proof of $(E)(G)(I)\sqsubseteq w \Ass 0$}
\subsubsection{Proof of $(H)\sqsubseteq w \Ass 1$}


\subsection{Specification of the Main Procedure}
The job of our main procedure, $\PROC \ EMIRP(\VALUE \ n: \nat, \RESULT \ r)$, 
is to find and return the $n^{th}$ emirp, where $n$ is a given positive parameter. 
Using the function $isEmirp()$ which is defined and proved above, we can specify 
our main procedure as:
\begin{gather*}
  \PROC \ EMIRP(\VALUE \ n: \nat, \RESULT \ r)\cdot \\
  \nt{n, r: 
  [
    n>0 ,  
    \sum_{i=2}^{r}isEmirp(i)= n_0 \And r \in Emirp
  ]}{(1)}
\end{gather*}  

\section{Task 2}
\begin{align*}
  \lrefstep{(1)}{\textbf{c-frame}}{
    r:
    [
      n>0 ,  
      \sum_{i=2}^{r}isEmirp(i)= n \And r \in Emirp
    ]
  }
  \\
  \refstep{\textbf{i-loc}}{
    \textbf{var}\ count \cdot count, r:
    [
      n>0 ,  
      \sum_{i=2}^{r}isEmirp(i)= n \And r \in Emirp
    ]
  }
  \\
  \refstep{\textbf{seq}}{
    \nt{
      count, r:
      [
        n>0 ,  
        Inv
      ]
    }{(2)};\\
    &\nt{
      count , r:
      [
        Inv,
        \sum_{i=2}^{r}isEmirp(i)= n \And r \in Emirp
      ]
    }{(3)}
  }
\end{align*}
where the loop invariant is defined by:
% TODO: Modify Inv 
\begin{gather*}
  Inv = 
  \left( \begin{array}{l}
    count = \sum_{i=2}^{r}isEmirp(i) \And n > 0\And 0 \leq count \leq n\And r \geq count
  \end{array}\right)
\end{gather*}
\begin{align*}
  \lrefstep{(2)}{Routine work: initialize the variables in the loop}{
    r \Ass 1; count \Ass 0;
  }
  \\
  % TODO: Check whether it's correct s-post 
  \lrefstep{(3)}{\textbf{s-post}, justified below}{
    count , r:
    [
      Inv,
      Inv \And (count = n \And r \in Emirp)
    ]
  }
  \\
  \refstep {\textbf{while}}{
    \WHILE ~count \neq n \Or r \notin Emirp\ ~\DO \\ 
    & \qquad 
    \nt{
      count , r:
      [
        Inv \And (count \neq n \Or r \notin Emirp),
        Inv 
      ]
    }{(4)}
    \\
    &\OD
  }
  \\
  \lrefstep{(4)}{\textbf{f-ass}, justified below}{
    \nt{
      count, r:
      [
        Inv \And (count \neq n \Or r \notin Emirp),
        Inv\subst{r+1}{r}
      ]
    }{(5)}
    \\
    & r:=r+1;
  }
  \\
  % TODO: Need to justify
  \\
  \lrefstep{(5)}{\textbf{c-frame, ass}, justified below}{
    count \Ass count + ISEMIRP(r);
  }
\end{align*}
We gather the code for the procedure body of EMIRP: 
\begin{gather*}
  \textbf{var}\ count;\\
  r \Ass 2; \\
  count \Ass 0;\\
  \WHILE ~count \neq n \Or r \notin Emirp ~ \DO \\
  \qquad r \Ass r+1;\\
  \qquad count \Ass count + ISEMIRP(r);\\
  \OD 
\end{gather*}


\subsection{Task 3}
\subsection{Task 4}

\end{document}
